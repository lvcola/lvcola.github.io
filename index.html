<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://o8yrrj7hr.bkt.clouddn.com/psb.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Lvcola</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						<li>Links</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/lvcola/lvcola.github.io" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
					        
								<a class="zhihu" target="_blank" href="https://www.zhihu.com/" title="zhihu">zhihu</a>
					        
								<a class="mail" target="_blank" href="/583159685@qq.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">待我十二块腹肌，嫁给我可好</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Lvcola</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="http://o8yrrj7hr.bkt.clouddn.com/psb.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Lvcola</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/lvcola/lvcola.github.io" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="https://www.zhihu.com/" title="zhihu">zhihu</a>
			        
						<a class="mail" target="_blank" href="/583159685@qq.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-linux下网络聊天室" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/17/linux下网络聊天室/" class="article-date">
  	<time datetime="2016-08-17T01:59:41.000Z" itemprop="datePublished">2016-08-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/17/linux下网络聊天室/">linux下网络聊天室</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="网络聊天室"><a href="#网络聊天室" class="headerlink" title="网络聊天室"></a>网络聊天室</h1><p>心得：1.利用非阻塞函数select来监测客服端套接字描述符的变化来监测多个终端的输入（最多不能超过FD_SETSIZE）   2.在开发过程中遇到了几个问题，一是tmp_inset改成inset后会导致只能连接一次，暂时这个问题还无法解决。 二是曾遇到一个困扰两三个礼拜的问题，即登录A后再登录B，A的就无法发送信息到服务器了。后来发现自己recv函数中的描述符是个定值，即每次连接之后这个值就不可逆的改变了，变成了B的描述符。解决方法：每次fd的描述符被加入了集合inset中，如果要处理需要的客户端，要给出对应的客户端描述符。 3.利用了双线程，服务器要有一个读信息的线程，一个将读到的信息发给所有客户端的线程。而客户端同理需要两个线程来处理读写。</p>
<p>还未解决： 1.账号密码应该放入一个数据库中，实现账户的注册登录 2.界面 3.能实现单对单聊天  4.心跳包还需要完善</p>
<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;sys/types.h&gt;
#include&lt;string.h&gt;
#include&lt;errno.h&gt;
#include&lt;netdb.h&gt;
#include&lt;netinet/tcp.h&gt;
#include&lt;arpa/inet.h&gt;
#include&lt;netinet/in.h&gt;
#include&lt;sys/time.h&gt;
#include&lt;unistd.h&gt;
#include&lt;sys/ioctl.h&gt;
#include&lt;pthread.h&gt;
#define BUFFER_SIZE 1024
#define N 10
char buf[BUFFER_SIZE];
struct sockaddr_in server_sockaddr,client_sockaddr;
int sockfd,client_fd;
fd_set inset;


void thread_1()
{
    int fd;
    int sin_size,count;
    fd_set tmp_inset;
    while(1)
        {      
                tmp_inset = inset;
                sin_size = sizeof(struct sockaddr_in);
                if(!select(FD_SETSIZE,&amp;tmp_inset,NULL,NULL,NULL) &gt; 0)
                {       perror(&quot;select:&quot;);
                }
                for(fd = 0; fd &lt; FD_SETSIZE;fd++)
                {
                        if(FD_ISSET(fd,&amp;tmp_inset) &gt; 0)
                        {
                                if(fd == sockfd)
                                {       if((client_fd = accept(sockfd,(struct sockaddr*)&amp;client_sockaddr,&amp;sin_size)) == -1)
                                        { perror(&quot;accept&quot;);
                                          exit(0);
                                        }
                                        FD_SET(client_fd,&amp;inset);
                                        printf(&quot;New connection from client%d\n&quot;,client_fd);
                                }
                                else
                                {
                                        if((count = recv(fd,buf,BUFFER_SIZE,0)) &gt; 0)
                                        { printf(&quot;%d:%s\n&quot;,fd,buf);

                                        }
                                        else
                                        { close(fd);
                                          FD_CLR(fd,&amp;inset);
                                          printf(&quot;Client %d has left\n&quot;,fd);
                                        }
                                }
                        }
                }
        }


}

void thread_2()
{    int fd;
    fd_set tmp_inset = inset;
    while(1)
    {    for(fd = 0; fd &lt; FD_SETSIZE;fd++)
        {    if(FD_ISSET(fd,&amp;tmp_inset) &gt; 0)
            {    if(fd != sockfd)
                {if(send(fd,buf,BUFFER_SIZE,0) == -1)
                    { perror(&quot;send2client&quot;);
                    }
                }
            }
        }
    }    
}



int main()
{    

    pthread_t id_1,id_2;
    if((sockfd = socket(AF_INET,SOCK_STREAM,0)) == -1 )
    {    perror(&quot;socket:&quot;);
        exit(1);
    }
    server_sockaddr.sin_family = AF_INET;
    server_sockaddr.sin_port = htons(4321);
    server_sockaddr.sin_addr.s_addr = INADDR_ANY;
    memset(server_sockaddr.sin_zero,0,8);

    int i = 1;
    setsockopt(sockfd,SOL_SOCKET,SO_REUSEADDR,&amp;i,sizeof(i));


    if(bind(sockfd,(struct sockaddr *)&amp;server_sockaddr,sizeof(struct sockaddr)) == -1)
    {    perror(&quot;bind:&quot;);
        exit(1);
    }
    printf(&quot;binding...\n&quot;);

    if(listen(sockfd,6)== -1)
    {    perror(&quot;listen:&quot;);
        exit(1);
    }
    printf(&quot;Listening...\n&quot;);

    FD_ZERO(&amp;inset);
    FD_SET(sockfd,&amp;inset);
//    int keepAlive = 1;
//    int keepIdle = 6;
//    int keepInterval = 5;
//    int keepCount = 3;
//    setsockopt(sockfd,SOL_SOCKET,SO_KEEPALIVE,(void *)&amp;keepAlive,sizeof(int));
//    setsockopt(sockfd,SOL_TCP,TCP_KEEPIDLE,(void *)&amp;keepIdle,sizeof(int));
//    setsockopt(sockfd,SOL_TCP,TCP_KEEPINTVL,(void *)&amp;keepInterval,sizeof(int));
//    setsockopt(sockfd,SOL_TCP,TCP_KEEPCNT,(void *)&amp;keepCount,sizeof(int));
    if(pthread_create(&amp;id_1,NULL,(void *)thread_1,NULL) != 0)
    {    printf(&quot;Create pthread fail&quot;);
        exit(1);
    }

    if(pthread_create(&amp;id_2,NULL,(void *)thread_2,NULL) != 0)
    {    printf(&quot;Create pthread fail&quot;);
        exit(1);
    }
    pthread_join(id_1,NULL);
    pthread_join(id_2,NULL);
    close(sockfd);
    exit(0);
}
</code></pre><p>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a  href="/2016/08/17/linux下网络聊天室/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-VS2010静态编译生成-exe文件-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/08/05/VS2010静态编译生成-exe文件-1/" class="article-date">
  	<time datetime="2016-08-05T03:54:21.000Z" itemprop="datePublished">2016-08-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/08/05/VS2010静态编译生成-exe文件-1/">VS2010静态编译生成.exe文件</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>VS2010静态编译生成的.exe可执行文件，可以免安装免DLL在其他电脑直接运行。</p>
<p>静态编译：就是在编译可执行文件的时候，将可执行文件需要调用的对应动态链接库（.so）中的部分提取出来，链接到可执行文件中去，使可执行文件在运行的时候不依赖动态链接库。</p>
<p>编译方式（debug）：<br>设置：<br>1、项目 -&gt; 配置属性-&gt;常规-&gt;MFC的使用：在静态库中使用MFC（如果有使用MFC）。<br>2、项目 -&gt; 配置属性-&gt;C/C++-&gt;代码生成-&gt;运行库 :选择 多线程调试（/MTd）。</p>
<p>编译时，选择的是debug，win32<br>然后执行编译生成方案，在该工程目录下的debug文件中，找到该.exe文件，即可在其他电脑运行。<br>debug方式生成的.exe文件会比较大，因为它包含了一些调试用的信息。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-绕过chinanet验证方法-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/18/绕过chinanet验证方法-1/" class="article-date">
  	<time datetime="2016-07-18T03:31:25.000Z" itemprop="datePublished">2016-07-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/18/绕过chinanet验证方法-1/">绕过chinanet验证方法</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>   最近一直在用chinanet手机验证免费上网。但是因为chinanet有免费时长，往往在需要的时候上不了网。我注意到，当免费时长用完网页打不开会自动跳转到chinanet验证，但是QQ能上网。很奇怪，决定了解下计算机无线网络的原理，找找有没有机会绕过chinanet的验证照常登录一些常用网站。  后来百度了一些资料，发现QQ能上是因为QQ不需要dns解析，那这样子就好办了，和小伙伴讨论了一下，总结出来两种方法。</p>
<h2 id="1-修改hosts文件夹"><a href="#1-修改hosts文件夹" class="headerlink" title="1.修改hosts文件夹"></a>1.修改hosts文件夹</h2><p>通过修改C:\Windows\System32\drivers\etc下的hosts，在自己电脑里建立一个关联数据库，把ping到的ip以及网址放入其中，这样子就能绕过dns解析。具体格式如下</p>
<pre><code># Modified hosts start

# xwj start
220.181.57.217 www.baidu.com
223.6.249.240  www.newcoder.com
# xwj end

# Modified hosts end
</code></pre><h2 id="2-直接设置静态dns"><a href="#2-直接设置静态dns" class="headerlink" title="2.直接设置静态dns"></a>2.直接设置静态dns</h2><p>114开头的dns多是基础电信运营商自用的DNS系统，修改dns看看chinanet是否傻逼没有封别人的dns</p>
<h2 id="3-用代理服务器访问网络"><a href="#3-用代理服务器访问网络" class="headerlink" title="3.用代理服务器访问网络"></a>3.用代理服务器访问网络</h2><p>（1）修改internet选项为LAN设置代理服务器<br>（2）使用vpn</p>
<hr>
<p>7.18中午吃饭的时候试了试，很遗憾，这三种方法都并不能解决这个问题。但是又发现一点很奇怪的东西，知乎竟然在这种情况下也能使用。（不是缓存，有图片有更新。其他页面打开都需要验证）但是不管是ping zhihu.com还是ping 知乎的Ip 都ping不通。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-huffman压缩" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/15/huffman压缩/" class="article-date">
  	<time datetime="2016-07-15T07:32:12.000Z" itemprop="datePublished">2016-07-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/15/huffman压缩/">huffman压缩</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="huffman压缩"><a href="#huffman压缩" class="headerlink" title="huffman压缩"></a>huffman压缩</h1><p>心得：在huffman.h中有一个encode()函数，其中定义了一个MyString类的变量str,但是给它赋好值return的时候就会出错，百思不得其解。问过老师，老师说是没有深拷贝。可我mystring中写了深拷贝。后来看C专家编程，看到P49的时候就懂。是因为当控制流离开局部变量的范围时，自动变量便自动失效，这就意味着即使返回一个指向局部变量的指针，当函数结束时，变量被销毁，谁也不知道这个指针所指向的地址内容是什么。只要将这个变量设置为static就能解决这个问题。</p>
<hr>
<h2 id="huffman-h"><a href="#huffman-h" class="headerlink" title="huffman.h"></a>huffman.h</h2><pre><code>#ifndef _HuffmanTree_H
#define _HuffmanTree_H
#include &lt;fstream&gt;
#include &quot;Seqlist.h&quot;
#include &quot;Mystring.h&quot;
#include &quot;TriElement.h&quot;

class HuffmanTree
{
 protected:
    MyString charset;//字符集
    Seqlist&lt;TriElement&gt;huftree;
    void encode(int i); //单解码
   public:
    HuffmanTree(MyString &amp;m,int weight[],int n);
    void printCode();
    MyString encode(MyString &amp; text);//编码，压缩
    void decode();//译码，解压缩

};



HuffmanTree::HuffmanTree(MyString &amp;m,int weight[], int n)//字符集，权值，长度
    :huftree(2*n-1)
{
    for (int i = 0; i &lt; n; i++)
    {
        this-&gt;charset.insert(i,m[i]);
        this-&gt;huftree.insert(TriElement(weight[i], -1, -1, -1));
    }

    for (int i = 0; i &lt; n - 1; i++)
    {
        int min1 = 0x7fffffff, min2 = min1, x1 = 0, x2 = x1;
        for (int j = 0; j &lt; n + i;j++)
            if (huftree[j].parent == -1 &amp;&amp; huftree[j].data &lt; min1)
            {
                min2 = min1;
                x2 = x1;
                min1 = huftree[j].data;
                x1 = j;
            }
            else if (huftree[j].parent == -1 &amp;&amp; huftree[j].data &lt; min2)
                {
                    min2 = huftree[j].data;
                    x2 = j;
                }

        huftree[x1].parent = n + i;
        huftree[x2].parent = n + i;
        huftree.insert(TriElement(huftree[x1].data + huftree[x2].data, -1, x1, x2));
    }
    cout &lt;&lt; &quot;Huffman 树的结点顺序表：&quot; &lt;&lt; this-&gt;huftree;
}
void  HuffmanTree::encode(int i)
{    MyString str;
    int child = i,parent = huftree[child].parent;//已经重载下标,huftree[i]是哈夫曼第i个
    while(parent != -1)//不是根节点
    {    if(huftree[parent].left == child)//是左子树
            str+=&apos;0&apos;;
        else
            str+=&apos;1&apos;;
        child = parent;
        parent = huftree[child].parent;
    }
    str.reverse();//反转字符串
    cout&lt;&lt;str&lt;&lt;&quot;,&quot;;//临时的方法，按书上会出现一个问题

}

void HuffmanTree::printCode()
{    
    cout &lt;&lt; &quot;Huffman 编码，&quot;;
    for (int i = 0; i &lt; this-&gt;charset.count(); i++)
    {    
        cout &lt;&lt; this-&gt;charset[i] &lt;&lt; &quot;：&quot;;
        //cout&lt;&lt;str&lt;&lt;&quot;,&quot;;
        encode(i) ;
    }
    cout &lt;&lt; endl;
}

MyString HuffmanTree::encode(MyString &amp;text)
{    static MyString codestr;
    ofstream fout;
    int child ,parent;//已经重载下标,huftree[i]是哈夫曼第i个
    int i,j;
    for(i = 0;i&lt;text.count();i++)
    {    MyString str;
        for(j = 0;j &lt; this-&gt;charset.count();j++)
            if(text[i] == this-&gt;charset[j])
                break;//此时j就是该字符在哈夫曼树中的位置
        child = j;
        parent = huftree[child].parent;
        while(parent != -1)//不是根节点
        {    if(huftree[parent].left == child)//是左子树
                str+=&apos;0&apos;;
            else
                str+=&apos;1&apos;;
            child = parent;
            parent = huftree[child].parent;
        }
        str.reverse();//反转字符串
        codestr += str;
    }
    //cout&lt;&lt;&quot;压缩后为：&quot;&lt;&lt;codestr;//临时的方法，按书上会出现一个问题
    //cout&lt;&lt;&quot;压缩比为&quot;&lt;&lt;codestr.count()&lt;&lt;&quot;:&quot;&lt;&lt;text.count()*8;//需要改，要改成浮点数
    fout.open(&quot;c://2.txt&quot;);
    fout&lt;&lt;codestr;
    fout.close();
    return codestr;
}

void HuffmanTree::decode()
{
    char s[1000];//源文档中字符信息
    ifstream fin;//
    fin.open(&quot;c://2.txt&quot;);//从C盘1.txt中读取文件信息
    fin &gt;&gt; s;//把文件中信息读入字符串s中
    MyString bef_text(s);//压缩后的字符信息
    fin.close();

    MyString af_text;

    int node = this-&gt;huftree.count() - 1;
    for (int i = 0; i &lt; bef_text.count(); i++)
    {
        if (bef_text[i] == &apos;0&apos;)
            node = huftree[node].left;
        else node = huftree[node].right;
        if (huftree[node].leaf())
        {
            af_text += this-&gt;charset[node];
            node = this-&gt;huftree.count() - 1;
        }
    }
    cout&lt;&lt;&quot;解码为&quot;&lt;&lt;af_text&lt;&lt;endl;
}


#endif
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a  href="/2016/07/15/huffman压缩/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-智能小车" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/07/05/智能小车/" class="article-date">
  	<time datetime="2016-07-05T02:41:07.000Z" itemprop="datePublished">2016-07-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/05/智能小车/">智能小车</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="防坠落智能小车"><a href="#防坠落智能小车" class="headerlink" title="防坠落智能小车"></a>防坠落智能小车</h1><p>心得:硬件设计需要细心，特别要注意各引脚和时钟的关系。有时候在两个不同头文件重复定义的相同引脚，会导致功能失效。另外可以用Led灯输出状态，这也是一个小技巧。</p>
<hr>
<h3 id="超声波模块实现防坠落"><a href="#超声波模块实现防坠落" class="headerlink" title="超声波模块实现防坠落"></a>超声波模块实现防坠落</h3><pre><code>void Ultran1_Init(void)//前置超声波模块
{
GPIO_InitTypeDef GPIO_InitStructure;
 RCC_APB2PeriphClockCmd(ULTRA_CLK, ENABLE);

GPIO_InitStructure.GPIO_Pin =ULTRA1_TRIG;       //发送电平引脚
 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;//推挽输出
 GPIO_Init(ULTRA_PORT, &amp;GPIO_InitStructure);
GPIO_ResetBits(ULTRA_PORT,ULTRA1_TRIG);

GPIO_InitStructure.GPIO_Pin =ULTRA1_ECHO;        //接收电平引脚
 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;//浮空输入
 GPIO_Init(ULTRA_PORT, &amp;GPIO_InitStructure);    
}


void Ultra1_Ranging(float *p)
{
u8 i;
u32 j;
float Ultr_Temp;    
for(i=0;i&lt;3;i++)
{
    TRIG1_Send=1;
    delay_ms(10);
    TRIG1_Send=0;
    while(!ECHO1_Reci);
    while(ECHO1_Reci)
    {
        delay_us(10);
        j++;
    }
    Ultr_Temp+=340/2*j;//最大测距距离3m
    j=0;
    delay_ms(60);//防止发射信号对回响信号的影响
}
*p=Ultr_Temp/3/1000;     //取三次平均值，减少误差cm
}
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
        <p class="article-more-link">
          <a  href="/2016/07/05/智能小车/#more">more >></a>
        </p>
      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Lvcola
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>